# 小波包分解的数学原理

## 1. 从时间序列到小波频段的计算过程

### 1.1 离散小波变换（DWT）基础

小波包分解基于**离散小波变换（Discrete Wavelet Transform, DWT）**。

#### 数学定义

对于时间序列信号 $x[n]$，DWT 将其分解为：

**低频成分（Approximation, cA）**:
$$cA[k] = \sum_n x[n] \cdot h[2k - n]$$

**高频成分（Detail, cD）**:
$$cD[k] = \sum_n x[n] \cdot g[2k - n]$$

其中：
- $h[n]$ 是**低通滤波器**（Low-pass filter）系数
- $g[n]$ 是**高通滤波器**（High-pass filter）系数
- $k$ 是采样后的索引（下采样，stride=2）

### 1.2 代码中的实现

```python
def _dwt_step(self, x):
    B, N, L = x.shape
    # 1. 填充（处理边界）
    x_padded = F.pad(x.reshape(B*N, 1, -1), (pad_len, pad_len), mode='circular')
    
    # 2. 卷积 + 下采样（stride=2）
    cA = F.conv1d(x_padded, self.dec_lo, stride=2)  # 低通滤波
    cD = F.conv1d(x_padded, self.dec_hi, stride=2)  # 高通滤波
    
    return cA, cD
```

**关键操作**：
1. **卷积**：使用滤波器系数对信号进行滤波
2. **下采样（stride=2）**：每2个采样点取1个，长度减半

### 1.3 Level=2 的完整分解过程

```
原始信号 x[n], 长度 L
    │
    ├─ Level 1: DWT 分解
    │     │
    │     ├─ cA₁[k] = Σ x[n] · h[2k-n]  (低频, 长度 L/2)
    │     │
    │     └─ cD₁[k] = Σ x[n] · g[2k-n]  (高频, 长度 L/2)
    │
    └─ Level 2: 对 cA₁ 和 cD₁ 分别再次 DWT
          │
          ├─ cA₁ → DWT
          │     ├─ cA₁-cA₂ = Σ cA₁[k] · h[2k-n]  (频段0: 最低频)
          │     └─ cA₁-cD₂ = Σ cA₁[k] · g[2k-n]  (频段1: 低中频)
          │
          └─ cD₁ → DWT
                ├─ cD₁-cA₂ = Σ cD₁[k] · h[2k-n]  (频段2: 中高频)
                └─ cD₁-cD₂ = Σ cD₁[k] · g[2k-n]  (频段3: 最高频)
```

## 2. 滤波器与基函数的关系

### 2.1 小波基函数的数学定义

小波基函数由**尺度函数（Scaling Function）$\phi(t)$** 和**小波函数（Wavelet Function）$\psi(t)$** 定义。

#### 双尺度方程（Two-scale Equation）

**尺度函数**：
$$\phi(t) = \sqrt{2} \sum_k h[k] \cdot \phi(2t - k)$$

**小波函数**：
$$\psi(t) = \sqrt{2} \sum_k g[k] \cdot \phi(2t - k)$$

其中 $g[k] = (-1)^k \cdot h[N-1-k]$（QMF关系）

### 2.2 滤波器系数 = 基函数的采样值

**关键关系**：
- **低通滤波器 $h[k]$** = 尺度函数 $\phi(t)$ 的**展开系数**
- **高通滤波器 $g[k]$** = 小波函数 $\psi(t)$ 的**展开系数**

对于 db4 小波：
- $h[k]$ 有 8 个系数（对应尺度函数）
- $g[k]$ 有 8 个系数（对应小波函数）

### 2.3 滤波器组（Filter Bank）结构

```
输入 x[n]
    │
    ├─ 低通滤波器 h[n] ──→ cA[k] (低频成分)
    │     ↓ 下采样
    │
    └─ 高通滤波器 g[n] ──→ cD[k] (高频成分)
          ↓ 下采样
```

**滤波器的作用**：
- **低通滤波器 $h[n]$**：提取信号的**低频成分**（平滑、趋势）
- **高通滤波器 $g[n]$**：提取信号的**高频成分**（细节、变化）

## 3. 小波包分解的完整数学过程

### 3.1 数学公式

对于 Level=2 的分解：

**Level 1**:
$$cA_1[k] = \sum_n x[n] \cdot h[2k - n]$$
$$cD_1[k] = \sum_n x[n] \cdot g[2k - n]$$

**Level 2** (对 cA₁ 分解):
$$cA_1\text{-}cA_2[k] = \sum_m cA_1[m] \cdot h[2k - m]$$
$$cA_1\text{-}cD_2[k] = \sum_m cA_1[m] \cdot g[2k - m]$$

**Level 2** (对 cD₁ 分解):
$$cD_1\text{-}cA_2[k] = \sum_m cD_1[m] \cdot h[2k - m]$$
$$cD_1\text{-}cD_2[k] = \sum_m cD_1[m] \cdot g[2k - m]$$

### 3.2 频域解释

每个频段对应不同的**频率范围**：

```
频率范围（从低到高）:
┌─────────────────────────────────────────┐
│ 频段0  │ 频段1  │ 频段2  │ 频段3  │
│最低频  │低中频  │中高频  │最高频  │
│0-π/4   │π/4-π/2 │π/2-3π/4│3π/4-π  │
└─────────────────────────────────────────┘
```

其中 $\pi$ 对应 Nyquist 频率（采样频率的一半）。

## 4. 代码实现详解

### 4.1 滤波器初始化

```python
# 代码第48-50行
wavelet_obj = pywt.Wavelet('db4')
self.register_buffer('dec_lo', torch.tensor(wavelet_obj.dec_lo, ...))
self.register_buffer('dec_hi', torch.tensor(wavelet_obj.dec_hi, ...))
```

- `dec_lo`: 低通滤波器系数 $h[k]$（8个系数）
- `dec_hi`: 高通滤波器系数 $g[k]$（8个系数）

### 4.2 单步 DWT

```python
def _dwt_step(self, x):
    # x: [B, N, L]
    x_padded = F.pad(x.reshape(B*N, 1, -1), (pad_len, pad_len), mode='circular')
    
    # 卷积 + 下采样
    cA = F.conv1d(x_padded, self.dec_lo, stride=2)  # 低通滤波
    cD = F.conv1d(x_padded, self.dec_hi, stride=2)  # 高通滤波
    
    return cA, cD
```

**数学等价**：
- `F.conv1d(..., stride=2)` 等价于：卷积 + 下采样
- 对应公式：$cA[k] = \sum_n x[n] \cdot h[2k-n]$

### 4.3 递归分解

```python
def forward(self, x):
    nodes = [x]  # 初始：原始信号
    
    for _ in range(self.level):  # level=2，循环2次
        next_nodes = []
        for node in nodes:
            cA, cD = self._dwt_step(node)  # DWT分解
            next_nodes.append(cA)  # 低频
            next_nodes.append(cD)  # 高频
        nodes = next_nodes
    
    return nodes  # 返回 2^level 个频段
```

## 5. 滤波器系数与基函数的关系（db4 示例）

### 5.1 db4 的滤波器系数

**低通滤波器 $h[k]$** (dec_lo):
```
h[0] = (1 + √3) / (4√2) ≈ 0.2304
h[1] = (3 + √3) / (4√2) ≈ 0.7148
h[2] = (3 - √3) / (4√2) ≈ 0.6309
h[3] = (1 - √3) / (4√2) ≈ -0.0280
...
```

**高通滤波器 $g[k]$** (dec_hi):
```
g[k] = (-1)^k · h[7-k]  (QMF关系)
```

### 5.2 基函数的构造

这些系数定义了 db4 的**尺度函数**和**小波函数**：

$$\phi(t) = \sqrt{2} \sum_{k=0}^{7} h[k] \cdot \phi(2t - k)$$

$$\psi(t) = \sqrt{2} \sum_{k=0}^{7} g[k] \cdot \phi(2t - k)$$

### 5.3 为什么是固定的？

- **数学最优性**：db4 小波基函数经过数学证明，具有最优的时频分辨率
- **正交性**：保证分解后的频段互不重叠（正交）
- **紧支撑**：有限支撑区间，计算效率高

## 6. 完整计算流程总结

```
时间序列 x[n]
    │
    ├─ 卷积 + 下采样 (使用 h[n])
    │     ↓
    │  cA₁[k] = Σ x[n]·h[2k-n]  (低频)
    │     │
    │     ├─ 卷积 + 下采样 (使用 h[n])
    │     │     ↓
    │     │  cA₁-cA₂  (频段0: 最低频)
    │     │
    │     └─ 卷积 + 下采样 (使用 g[n])
    │           ↓
    │        cA₁-cD₂  (频段1: 低中频)
    │
    └─ 卷积 + 下采样 (使用 g[n])
          ↓
       cD₁[k] = Σ x[n]·g[2k-n]  (高频)
          │
          ├─ 卷积 + 下采样 (使用 h[n])
          │     ↓
          │  cD₁-cA₂  (频段2: 中高频)
          │
          └─ 卷积 + 下采样 (使用 g[n])
                ↓
             cD₁-cD₂  (频段3: 最高频)
```

## 7. 关键概念总结

| 概念 | 数学表示 | 代码实现 | 作用 |
|------|---------|---------|------|
| **低通滤波器** | $h[n]$ | `dec_lo` | 提取低频成分 |
| **高通滤波器** | $g[n]$ | `dec_hi` | 提取高频成分 |
| **尺度函数** | $\phi(t)$ | 由 $h[n]$ 定义 | 低频基函数 |
| **小波函数** | $\psi(t)$ | 由 $g[n]$ 定义 | 高频基函数 |
| **DWT** | 卷积 + 下采样 | `F.conv1d(..., stride=2)` | 单层分解 |
| **WPD** | 递归 DWT | `forward()` 循环 | 多层分解 |

## 8. 为什么这样设计？

1. **数学严谨性**：基于小波理论的数学基础
2. **时频分析**：同时提供时间和频率信息
3. **多分辨率**：不同 level 提供不同精度的频率分解
4. **计算效率**：卷积操作可以高效实现

## 参考文献

1. Mallat, S. (2009). "A Wavelet Tour of Signal Processing"
2. Daubechies, I. (1988). "Orthonormal bases of compactly supported wavelets"
3. PyWavelets Documentation
