# 下采样（Downsampling）详解

## 1. 基本概念

**下采样（Downsampling）**，也称为**降采样**或**抽取（Decimation）**，是指**减少信号采样率**的操作。

### 1.1 简单理解

- **原始信号**: 有 100 个数据点
- **下采样（stride=2）**: 每 2 个点取 1 个，得到 50 个数据点
- **结果**: 采样率减半，数据点减半

### 1.2 数学定义

对于信号 $x[n]$，下采样因子为 $M$ 的操作：

$$y[n] = x[M \cdot n]$$

即：只保留索引为 $M$ 的倍数的采样点。

## 2. 在小波包分解中的作用

### 2.1 为什么需要下采样？

小波包分解中，每次 DWT 分解后：
- **频率范围减半**：低频和高频各占一半
- **采样率可以减半**：根据 Nyquist 采样定理，采样率只需是最高频率的 2 倍
- **数据量减半**：保持信息量不变，但数据点减半

### 2.2 代码中的实现

```python
# 代码第57-58行
cA = F.conv1d(x_padded, self.dec_lo, stride=2)  # stride=2 实现下采样
cD = F.conv1d(x_padded, self.dec_hi, stride=2)  # stride=2 实现下采样
```

**`stride=2` 的作用**：
- 卷积核每移动 2 步才计算一次
- 相当于：卷积 + 下采样（每2个点取1个）

## 3. 可视化示例

### 3.1 下采样过程

```
原始信号: [x₀, x₁, x₂, x₃, x₄, x₅, x₆, x₇, ...]
           ↓ 下采样 (stride=2)
下采样后: [x₀, x₂, x₄, x₆, ...]
          ↑   ↑   ↑   ↑
          保留 跳过 保留 跳过
```

### 3.2 在小波包分解中的完整流程

```
原始信号: [x₀, x₁, x₂, ..., x₉₅]  (96个点)
    │
    ├─ 低通滤波 + 下采样 (stride=2)
    │     ↓
    │  cA₁: [cA₀, cA₁, ..., cA₅₁]  (52个点，长度减半)
    │     │
    │     ├─ 低通滤波 + 下采样 (stride=2)
    │     │     ↓
    │     │  cA₁-cA₂: [cA₂₀, cA₂₁, ..., cA₂₂₉]  (30个点)
    │     │
    │     └─ 高通滤波 + 下采样 (stride=2)
    │           ↓
    │        cA₁-cD₂: [cD₂₀, cD₂₁, ..., cD₂₂₉]  (30个点)
    │
    └─ 高通滤波 + 下采样 (stride=2)
          ↓
       cD₁: [cD₀, cD₁, ..., cD₅₁]  (52个点，长度减半)
          │
          ├─ 低通滤波 + 下采样 (stride=2)
          │     ↓
          │  cD₁-cA₂: [cA₂₀, cA₂₁, ..., cA₂₂₉]  (30个点)
          │
          └─ 高通滤波 + 下采样 (stride=2)
                ↓
             cD₁-cD₂: [cD₂₀, cD₂₁, ..., cD₂₂₉]  (30个点)
```

## 4. 为什么下采样不会丢失信息？

### 4.1 Nyquist 采样定理

根据 **Nyquist 采样定理**：
- 如果信号的最高频率是 $f_{max}$
- 采样率只需要 $\geq 2 \times f_{max}$ 就能完整恢复信号

### 4.2 小波分解的频率划分

在小波包分解中：
- **原始信号**: 频率范围 $[0, \pi]$（归一化频率）
- **Level 1 分解后**:
  - 低频 cA₁: 频率范围 $[0, \pi/2]$
  - 高频 cD₁: 频率范围 $[\pi/2, \pi]$
- **采样率可以减半**: 因为每个频段的最高频率减半了

### 4.3 信息量守恒

```
原始信号: 96 个点，频率范围 [0, π]
    ↓ 分解 + 下采样
cA₁: 52 个点，频率范围 [0, π/2]
cD₁: 52 个点，频率范围 [π/2, π]
    ↓
总信息量: 52 + 52 = 104 个点？不对！

实际上，由于频率范围减半，每个频段只需要一半的采样率，
所以总的有效信息量保持不变。
```

## 5. 代码中的具体实现

### 5.1 PyTorch 的 conv1d with stride

```python
# 代码第57行
cA = F.conv1d(x_padded, self.dec_lo, stride=2)
```

**等价于**：
```python
# 1. 先卷积（无下采样）
cA_full = F.conv1d(x_padded, self.dec_lo, stride=1)
# 输出长度: L + pad_len*2 - 8 + 1

# 2. 再下采样（每2个取1个）
cA = cA_full[:, :, ::2]  # 等价于 stride=2
# 输出长度: (L + pad_len*2 - 8 + 1) // 2
```

### 5.2 实际例子

```python
import torch
import torch.nn.functional as F

# 模拟输入
x = torch.randn(1, 1, 96)  # [B, C, L]
filter_h = torch.randn(1, 1, 8)  # 滤波器

# 方法1: 使用 stride=2（卷积+下采样一步完成）
result1 = F.conv1d(x, filter_h, stride=2)
print(f'stride=2 输出长度: {result1.shape[-1]}')

# 方法2: 先卷积再下采样（等价操作）
result2_full = F.conv1d(x, filter_h, stride=1)
result2 = result2_full[:, :, ::2]  # 下采样
print(f'先卷积再下采样输出长度: {result2.shape[-1]}')
```

## 6. 下采样 vs 上采样

| 操作 | 定义 | 效果 | 用途 |
|------|------|------|------|
| **下采样** | 减少采样点 | 采样率降低，数据点减少 | 分解、压缩 |
| **上采样** | 增加采样点 | 采样率提高，数据点增加 | 重构、插值 |

### 6.1 下采样（Downsampling）

```
[x₀, x₁, x₂, x₃, x₄, x₅]  (6个点)
    ↓ stride=2
[x₀, x₂, x₄]  (3个点)
```

### 6.2 上采样（Upsampling）

```
[x₀, x₁, x₂]  (3个点)
    ↓ 上采样（插零）
[x₀, 0, x₁, 0, x₂, 0]  (6个点)
```

## 7. 在小波包分解中的重要性

### 7.1 为什么必须下采样？

1. **频率范围减半**：分解后每个频段的频率范围是原来的一半
2. **采样率可以减半**：根据 Nyquist 定理
3. **数据量减半**：保持信息量不变，但存储和计算量减少
4. **递归分解**：为下一层分解做准备

### 7.2 不下采样会怎样？

如果不下采样：
- 数据量会指数增长：Level 2 会有 4×L 个数据点
- 计算量大幅增加
- 信息冗余：频率范围减半了，但采样率没变

### 7.3 下采样的好处

- ✅ **数据量减少**：每层减半，总数据量可控
- ✅ **计算效率**：减少后续计算量
- ✅ **信息保持**：通过 Nyquist 定理保证不丢失信息
- ✅ **多分辨率**：不同 level 提供不同精度的频率分解

## 8. 实际例子

### 8.1 长度变化

```
原始信号: 96 个点
    ↓ Level 1 分解 + 下采样
cA₁, cD₁: 各 52 个点（约 L/2）
    ↓ Level 2 分解 + 下采样
4个频段: 各 30 个点（约 L/4）
```

### 8.2 频率分辨率

```
原始信号: 频率分辨率 = π/96
    ↓ Level 1
cA₁, cD₁: 频率分辨率 = (π/2)/52 ≈ π/104
    ↓ Level 2
4个频段: 频率分辨率 = (π/4)/30 ≈ π/120
```

**注意**：虽然每个频段的点数减少了，但频率范围也减半了，所以频率分辨率大致保持不变。

## 9. 总结

### 下采样的核心要点

1. **定义**：每 $M$ 个点取 1 个，采样率降低 $M$ 倍
2. **在小波包中**：`stride=2` 实现下采样，长度减半
3. **为什么可行**：频率范围减半，采样率可以减半（Nyquist 定理）
4. **作用**：减少数据量，提高计算效率，保持信息量

### 关键公式

- **下采样操作**：$y[n] = x[2n]$（stride=2）
- **长度变化**：$L_{out} = \lfloor L_{in}/2 \rfloor$
- **频率范围**：$[0, \pi] \rightarrow [0, \pi/2]$ 或 $[\pi/2, \pi]$

### 代码对应

```python
# stride=2 同时实现卷积和下采样
cA = F.conv1d(x, filter_h, stride=2)
# 等价于: 卷积 + 下采样（每2个点取1个）
```
